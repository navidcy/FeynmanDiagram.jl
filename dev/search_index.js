var documenterSearchIndex = {"docs":
[{"location":"manual/interaction/#Interaction/Scattering-Amplitude-Convention","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"","category":"section"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"In general, the interaction (or scattering amplitude) between two spin-12 particles only has two independent spin components. Here we briefly review some of the common conventions of the spin components in literature, and show how to map between different conventions.","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"We assume a particle from the left collides with a particle from the right. Due to the interaction between the two particles, one of them scatters to the left, and the other to the right. ","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"We will use the index alphabetagammadelta to label the left incoming, the left outgoing, the right incoming and the right outgoing particles. We assume four legs associate with four momentum-frequency vectors k_1 k_2 k_3 k_4.","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"There are two possible scatterings: a direct scattering where the two particles don't permutate after the collision, and an exchange scattering where the two particles permutate. Therefore, the total scattering amplitude has two contributions,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v_alphabetagammadelta(1234) = v^d_alphabetagammadelta(1234)+v^e_alphabetagammadelta(1234)","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"where the exchange contribution is different from the direct counterpart up to an exchange of two outgoing legs and an overall particle statistic sign xi =pm 1,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_alphabetagammadelta(1234) = xi v^d_alphadeltagammabeta(1432)","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"where we have abbreviated the momentum-frequency vectors as indices.","category":"page"},{"location":"manual/interaction/#.-Spin-symmetric-and-asymmetric-convention:","page":"Interaction/Scattering-Amplitude Convention","title":"1. Spin symmetric and asymmetric convention:","text":"","category":"section"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"A interaction is split into a term that is independent of the spin (e.g., Coulomb interaction between electrons) and a term with spin dependence (e.g., ferromagnetic/antiferromagnetic interaction). This convention is commonly used in textbooks of Fermi liquid theory.","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^d_alphabetagammadelta(1234) equiv v^s_1234delta_alphabetadelta_gammadelta + v^a_1234 vecsigma_alphabetacdot vecsigma_gammadelta","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"where the superscript d means the scattering is direct.","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"If two particles permute after the collision, then one needs to exchange beta leftrightarrow gamma and other internal variables,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_alphabetagammadelta(1234) = xi v^s_1432delta_alphadeltadelta_gammabeta + xi v^a_1432 vecsigma_alphadeltacdot vecsigma_gammabeta","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_alphabetagammadelta(1234) = xifracv^s_1432+3v^a_14322delta_alphabetadelta_gammadelta + xi fracv^s_1432-v^a_14322 vecsigma_alphabetacdot vecsigma_gammadelta","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"To derive the above equations, we use the identity vecsigma_alphabetacdot vecsigma_gammadelta=2 delta_alpha delta delta_beta gamma-delta_alpha beta delta_gamma delta, which gives the following equations,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"delta_alphadeltadelta_gammabeta=frac12delta_alphabetadelta_gammadelta+frac12vecsigma_alphabetacdot vecsigma_gammadelta","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"and,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"vecsigma_alphadeltacdot vecsigma_gammabeta=frac32delta_alphabetadelta_gammadelta-frac12vecsigma_alphabetacdot vecsigma_gammadelta","category":"page"},{"location":"manual/interaction/#.-Spin-\\uparrow\\uparrow-and-\\uparrow\\downarrow-convention:","page":"Interaction/Scattering-Amplitude Convention","title":"2. Spin uparrowuparrow and uparrowdownarrow convention:","text":"","category":"section"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"An alternative parameterization of the interaction matrix is by specifiying the spin components v_uparrowuparrow equiv v_uparrowuparrowuparrowuparrow and v_uparrowdownarrow equiv v_uparrowuparrowdownarrowdownarrow. They can be derived from v_s and v_a by the simple relation,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^d_uparrowuparrow(1234) = v^s_1234+v^a_1234","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^d_uparrowdownarrow(1234) = v^s_1234-v^a_1234","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"If two particles permute after the collision, the exchange interaction v^e,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_uparrowuparrow(1234) = xifracv^s_1432+3v^a_14322+xifracv^s_1432-v^s_14322 = xi v^s_1432+ xi v^a_1432","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_uparrowdownarrow(1234) = xifracv^s_1432+3v^a_14322-xifracv^s_1432-v^s_14322 = 2 xi v^a_1432","category":"page"},{"location":"lib/exprtree/#Diagrams-as-an-Expression-Tree","page":"Diagrams as an Expression Tree","title":"Diagrams as an Expression Tree","text":"","category":"section"},{"location":"lib/exprtree/#API","page":"Diagrams as an Expression Tree","title":"API","text":"","category":"section"},{"location":"lib/exprtree/","page":"Diagrams as an Expression Tree","title":"Diagrams as an Expression Tree","text":"Modules = [FeynmanDiagram.ExprTree]","category":"page"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.CachedPool","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.CachedPool","text":"struct CachedPool{O,T}\n\n    Use this pool to host the objects that are heavy to evaluate so that one wants to cache their status.\n    The user should defines a compare\n\nMembers\n\nname::Symbol : name of the pool\nobject::O    : object\ncurrent::T      : current status\nnew::T       : the new status wants to assign later\nversion::Int128 : the current version\nexcited::Bool   : if set to excited, then the current status needs to be replaced with the new status\n\n\n\n\n\n","category":"type"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.ExpressionTree","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.ExpressionTree","text":"mutable struct ExpressionTree{V,PARA,F,W}\n\nDiagram Object represents a set of Feynman diagrams in an experssion tree (forest) structure\n\nMembers\n\nname::Symbol                     : Name of the tree\nloopBasis::V                     : Tuple of pools of cached basis  in a format of (BasisPool1, BasisPool2, ...)\nnode::CachedPool{Node{PARA,F},W} : Pool of the nodes in the diagram tree\nroot::Vector{Int}                : indices of the cached nodes that are the root(s) of the diagram tree. Each element corresponds to one root.\n\n\n\n\n\n","category":"type"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.LoopPool","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.LoopPool","text":"struct LoopPool{T}\n\nPool of loop basis. Each loop basis corresponds to a loop variable.\nA loop variable is a linear combination of N independent loops. The combination coefficients is what we call a loop basis.\nFor example, if a loop is a momentum K, then\n\nvaribale_i = K_1*basis[1, i] + K_2*basis[2, i] + K_3*basis[3, i] + ...\n\nMembers\n\nname::Symbol : name of the pool\ndim::Int     : dimension of a loop variable (for example, the dimension of a momentum-frequency loop variable is (d+1) where d is the spatial dimension)\nN::Int       : number of independent loops (dimension of loop basis)\nbasis::Matrix{T}    : Matrix of (N x Nb) that stores the loop basis, where Nb is the number of loop basis (or number of loop variables).\ncurrent::Matrix{T}  : Matrix of (dim x Nb) that stores the loop variables, where Nb is the number of loop basis (or number of loop variables).\n\n\n\n\n\n","category":"type"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.Node","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.Node","text":"mutable struct Node{PARA,F}\n\nNode Object, which is the building block of the diagram tree. Each node is a collection of CACHED proapgator objects and other child CACHED node objects\n\nMembers\n\npara::PARA     : user-defined parameters, which will be used to evaluate the factor and the weight of the node (e.g., if the node represents a vertex function, then the parameter may be the momentum basis of the external legs)\noperation::Int : #1: multiply, 2: add, ...\nfactor::F      : additional factor of the node\ncomponents::Vector{Vector{Int}}  : Index to the cached propagators stored in certain pools. Each Vector{Int} is for one kind of propagator.\nchildNodes::Vector{Int}  : Indices to the cached nodes stored in certain pool. They are the child of the current node in the diagram tree.\nparent::Int : Index to the cached nodes which is the parent of the current node.\n\n\n\n\n\n","category":"type"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.addnode!-Union{Tuple{W}, Tuple{F}, Tuple{PARA}, Tuple{V}, Tuple{ExpressionTree{V, PARA, F, W}, Any, Any, Union{Tuple, AbstractVector}}, Tuple{ExpressionTree{V, PARA, F, W}, Any, Any, Union{Tuple, AbstractVector}, Any}} where {V, PARA, F, W}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.addnode!","text":"function addnode!(diag::ExpressionTree{V,PARA,F,W}, operator, name, children::Union{Tuple, AbstractVector}, factor = 1.0; para = nothing) where {V,PARA,F,W}\n\nAdd a node into the expression tree.\n\nArguments\n\ndiag::ExpressionTree  : diagrammatic experssion tree.\noperator::Int         : #1: multiply, 2: add, ...\nname                  : name of the node\nchildren              : Indices to the cached nodes stored in certain pool. They are the child of the current node in the diagram tree. It should be in the format of Vector{Int}.\nfactor = 1.0          : Factor of the node\npara = nothing        : Additional paramenter required to evaluate the node. Set to nothing by default.\n\n\n\n\n\n","category":"method"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.addpropagator!-Union{Tuple{W}, Tuple{F}, Tuple{PARA}, Tuple{V}, Tuple{ExpressionTree{V, PARA, F, W}, Any}, Tuple{ExpressionTree{V, PARA, F, W}, Any, Any}} where {V, PARA, F, W}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.addpropagator!","text":"function addPropagator!(diag::ExpressionTree, name, factor = 1.0; site = [], loop = nothing, para = nothing, order::Int = 0)\n\nAdd a propagator into the diagram tree.\n\nArguments\n\ndiag           : diagrammatic experssion tree.\norder::Int = 0 : Order of the propagator.\nname = :none   : name of the propagator.\nfactor = 1     : Factor of the propagator.\nsite = []      : site basis (e.g, time and space coordinate) of the propagator.\nloop = nothing : loop basis (e.g, momentum and frequency) of the propagator.\npara = nothing : Additional paramenter required to evaluate the propagator.\n\n\n\n\n\n","category":"method"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.getNode-Tuple{Any, Int64}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.getNode","text":"function getNode(diag::Diagrams, nidx::Int)\n\nget Node in the diag with the index nidx.\n\n\n\n\n\n","category":"method"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.getNodeWeight-Tuple{Any, Int64}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.getNodeWeight","text":"function getNodeWeight(tree, nidx::Int)\n\nget Node weight in the diagram experssion tree with the index nidx.\n\n\n\n\n\n","category":"method"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.showTree-Tuple{ExpressionTree, Int64}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.showTree","text":"showTree(diag::Diagrams, _root = diag.root[end]; verbose = 0, depth = 999)\n\nVisualize the diagram tree using ete3 python package\n\n#Arguments\n\ndiag: the Diagrams struct to visualize\n_root: the index of the root node to visualize\nverbose=0: the amount of information to show\ndepth=999: deepest level of the diagram tree to show\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#Parquet-Algorithm-to-Build-Diagrams","page":"Parquet Algorithm to Build Diagrams","title":"Parquet Algorithm to Build Diagrams","text":"","category":"section"},{"location":"lib/parquet/#API","page":"Parquet Algorithm to Build Diagrams","title":"API","text":"","category":"section"},{"location":"lib/parquet/","page":"Parquet Algorithm to Build Diagrams","title":"Parquet Algorithm to Build Diagrams","text":"Modules = [FeynmanDiagram.Parquet]","category":"page"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.ParquetBlocks","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.ParquetBlocks","text":"struct ParquetBlocks\n\nThe channels of the left and right sub-vertex4 of a bubble diagram in the parquet equation\n\n#Members\n\nphi   : channels of left sub-vertex for the particle-hole and particle-hole-exchange bubbles\nppi   : channels of left sub-vertex for the particle-particle bubble\nΓ4   : channels of right sub-vertex of all channels\n\n\n\n\n\n","category":"type"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.green-Union{Tuple{DiagPara{W}}, Tuple{W}, Tuple{DiagPara{W}, Any}, Tuple{DiagPara{W}, Any, Any}, Tuple{DiagPara{W}, Any, Any, Any}} where W","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.green","text":"green(para::DiagPara, extK = DiagTree.getK(para.totalLoopNum, 1), extT = para.hasTau ? (1, 2) : (0, 0), subdiagram = false;\n    name = :G, resetuid = false, blocks::ParquetBlocks=ParquetBlocks())\n\nBuild composite Green's function.\nBy definition, para.firstTauIdx is the first Tau index of the left most self-energy subdiagram.\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nextT: [Tau index of the left leg, Tau index of the right leg]\nsubdiagram      : a sub-vertex or not\nname            : name of the diagram\nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA Diagram object or nothing if the Green's function is illegal. \n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.polarization-Union{Tuple{DiagPara{W}}, Tuple{W}, Tuple{DiagPara{W}, Any}, Tuple{DiagPara{W}, Any, Any}} where W","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.polarization","text":"function polarization(para, extK = DiagTree.getK(para.totalLoopNum, 1), subdiagram = false; name = :Π, resetuid = false, blocks::ParquetBlocks=ParquetBlocks())\n\nGenerate polarization diagrams using Parquet Algorithm.\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :response, :diagram, :hash. \nAll polarization share the same external Tau index. With imaginary-time variables, they are extT = (para.firstTauIdx, para.firstTauIdx+1)\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.sigma-Union{Tuple{DiagPara{W}}, Tuple{W}, Tuple{DiagPara{W}, Any}, Tuple{DiagPara{W}, Any, Any}} where W","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.sigma","text":"function sigma(para, extK = DiagTree.getK(para.totalLoopNum, 1), subdiagram = false; name = :Σ, resetuid = false, blocks::ParquetBlocks=ParquetBlocks())\n\nBuild sigma diagram. \nWhen sigma is created as a subdiagram, then no Fock diagram is generated if para.filter contains NoFock, and no sigma diagram is generated if para.filter contains Girreducible\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nsubdiagram      : a sub-vertex or not\nname            : name of the diagram\nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :type, :extT, :diagram, :hash\nAll sigma share the same incoming Tau index, but not the outgoing one\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.vertex3-Union{Tuple{DiagPara{WW}}, Tuple{WW}, Tuple{DiagPara{WW}, Any}, Tuple{DiagPara{WW}, Any, Any}} where WW","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.vertex3","text":"function vertex3(para, extK = [DiagTree.getK(para.totalLoopNum, 1), DiagTree.getK(para.totalLoopNum, 2)],\n    subdiagram = false; name = :Γ3, chan = [PHr, PHEr, PPr, Alli], resetuid = false, \n    blocks::ParquetBlocks=ParquetBlocks()\n    )\n\nGenerate 3-vertex diagrams using Parquet Algorithm.\nWith imaginary-time variables, all vertex3 generated has the same bosonic Tidx ``extT[1]=para.firstTauIdx`` and the incoming fermionic Tidx ``extT[2]=para.firstTauIdx+1``.\n\n#Arguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loops as a vector [bosonic leg, fermionic in, fermionic out]. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nchan            : vector of channels of the current 4-vertex. \nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :response, :extT, :diagram, :hash. \n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.vertex4-Union{Tuple{DiagPara{W}}, Tuple{W}, Tuple{DiagPara{W}, Any}, Tuple{DiagPara{W}, Any, AbstractVector}, Tuple{DiagPara{W}, Any, AbstractVector, Any}} where W","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.vertex4","text":"vertex4(para::DiagPara,\n    extK = [DiagTree.getK(para.totalLoopNum, 1), DiagTree.getK(para.totalLoopNum, 2), DiagTree.getK(para.totalLoopNum, 3)],\n    chan::AbstractVector = [PHr, PHEr, PPr, Alli],\n    subdiagram = false;\n    level = 1, name = :none, resetuid = false,\n    subchannel::Symbol=:All, #:All, :W, :Lver3, :Rver3, :RPA\n    blocks::ParquetBlocks=ParquetBlocks(),\n    blockstoplevel::ParquetBlocks=blocks\n    )\n\nGenerate 4-vertex diagrams using Parquet Algorithm\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loops as a vector [left in, left out, right in, right out]. \nchan            : vector of channels of the current 4-vertex. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nlevel           : level in the diagram tree\nresetuid        : restart uid count from 1\nsubchannel      : :All, :W, :Lver3, :Rver3, :RPA to select all, W-interaction, left-vertex-correction, right-vertex-correction or RPA-interaction diagrams\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\nblockstoplevel  : building blocks of the Parquet equation at the toplevel. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :response, :type, :extT, :diagram, :hash\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#Usage","page":"Parquet Algorithm to Build Diagrams","title":"Usage","text":"","category":"section"},{"location":"lib/parquet/","page":"Parquet Algorithm to Build Diagrams","title":"Parquet Algorithm to Build Diagrams","text":"using FeynmanDiagram\npara = DiagPara(type = Ver4Diag, innerLoopNum = 1, hasTau = true);\nParquet.vertex4(para)\n\npara = DiagPara(type = Ver3Diag, innerLoopNum = 1, hasTau = true);\nParquet.vertex3(para)\n\npara = DiagPara(type = SigmaDiag, innerLoopNum = 1, hasTau = true);\nParquet.sigma(para)\n\npara = DiagPara(type = PolarDiag, innerLoopNum = 1, hasTau = true);\nParquet.polarization(para)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FeynmanDiagram","category":"page"},{"location":"#FeynmanDiagram","page":"Home","title":"FeynmanDiagram","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FeynmanDiagram.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [FeynmanDiagram]","category":"page"},{"location":"#FeynmanDiagram.innerTauNum-Tuple{FeynmanDiagram.DiagramType, Any, Any}","page":"Home","title":"FeynmanDiagram.innerTauNum","text":"function innerTauNum(type::DiagramType, innerLoopNum, interactionTauNum)\n\ninternal imaginary-time degrees of freedom for a given diagram type and internal loop number.\nFor the vertex functions (self-energy, polarization, vertex3, and vertex4), innerTauNum is equivalent to tauNum.\nFor the Green function, tauNum = innerTauNum + external tauNum\n\n\n\n\n\n","category":"method"},{"location":"#Parameters.reconstruct-Union{Tuple{W}, Tuple{Type{DiagPara{W}}, DiagPara{W}, Any}} where W","page":"Home","title":"Parameters.reconstruct","text":"Parameters.reconstruct(p::DiagPara; kws...)\n\nType-stable version of the Parameters.reconstruct\n\n\n\n\n\n","category":"method"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/parquet.md\",\n    \"lib/diagtree.md\",\n    \"lib/exprtree.md\",\n]\nDepth = 2","category":"page"},{"location":"manual/hubbard_atom/#Hubbard-Atom-as-a-Test-Case","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"","category":"section"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"One may use the Hubbard atom model to benchmark the Feynman diagrams generated by FeynmanDiagram.jl. In this note, we derive the vertex functions and their power expansion in interaction. The test is implemented in the test folder.","category":"page"},{"location":"manual/hubbard_atom/#Hamiltonian","page":"Hubbard Atom as a Test Case","title":"1 Hamiltonian","text":"","category":"section"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"hatH=U n_uparrow n_downarrow-mu (n_uparrow+n_downarrow)","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"where U is the on-site interaction, mu is the chemical potential.","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"The eigenstates are,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"left 0 right\n: E_0=0.\nleft uparrow right\nand left downarrow right : E_1=-mu.\nleft uparrow downarrow right\n: E_2=U-2mu.","category":"page"},{"location":"manual/hubbard_atom/#Partition-sum","page":"Hubbard Atom as a Test Case","title":"2 Partition sum","text":"","category":"section"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"Z=1+2e^mubeta+e^-beta(U-2mu)","category":"page"},{"location":"manual/hubbard_atom/#Two-point-Green's-function","page":"Hubbard Atom as a Test Case","title":"3 Two-point Green's function","text":"","category":"section"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"For the imaginary-time tau0,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"G(tau)=lefttextT c_uparrow(tau) c^+_uparrow(0) right=frac1Zsum_n left nrighte^-(beta-tau)Hc_uparrow e^-tau H c^+_uparrow left n right","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"Only the states left 0 right and left downarrow right contribute,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"G(tau)=frace^mu tau+e^mu betae^-(U-mu)tauZ","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"For example, at half filling mu=U2, there is one particle and,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"G(tau)=frace^-Utau2+e^-U(beta-tau)22(1+e^-Ubeta2)","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"Transform to the Matsubara frequency,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"G(iomega_n) = int_0^beta G(tau)e^iomega_ntau dtau","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"G(iomega_n)=-frac1Zleft(frac1+e^mu betaiomega_n+mu+e^mubetafrac1+e^-(U-mu)betaiomega_n-(U-mu)right)","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"By setting U=0, one can show that the above dressed Green's function reduce to the bare one,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"g(iomega_n) = -frac1iomega_n+mu","category":"page"},{"location":"manual/hubbard_atom/#Self-energy","page":"Hubbard Atom as a Test Case","title":"4 Self-energy","text":"","category":"section"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"The self-energy is defined as G^-1(iomega_n)=g^-1(iomega_n)-Sigma(iomega_n), so that","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"Sigma(iomega_n) = fracU e^beta  mu  (mu +i w) left(e^beta  mu +e^beta  Uright)e^beta  U (-mu +U-i w)+e^beta  (mu +U) (-2 mu +U-2 i w)-e^2 beta  mu  (mu +i w)","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"For benchmark purpose, here we also provide the power expansion of the self-energy at the low-energy limit omega_0 = pi beta with mu=0,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"Sigma(iomega_0) = -fracU2+frac(pi +2 i) beta  U^28 pi -fracleft(pi ^2-4right) beta ^2 U^332 pi ^2-fracleft(24 i-12 pi +6 i pi ^2+pi ^3right) beta ^3 U^4384 pi ^3+fracleft(-48-48 i pi -24 pi ^2+12 i pi ^3+5 pi ^4right) beta ^4 U^51536 pi ^4+Oleft(U^6right)","category":"page"},{"location":"lib/diagtree/#Diagrams-as-an-AbstractTree","page":"Diagrams as an AbstractTree","title":"Diagrams as an AbstractTree","text":"","category":"section"},{"location":"lib/diagtree/#API","page":"Diagrams as an AbstractTree","title":"API","text":"","category":"section"},{"location":"lib/diagtree/","page":"Diagrams as an AbstractTree","title":"Diagrams as an AbstractTree","text":"Modules = [FeynmanDiagram.DiagTree]","category":"page"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.BareGreenNId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.BareGreenNId","text":"time-ordered N-point Bare Green's function\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.BareHoppingId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.BareHoppingId","text":"hopping function c⁺c⁻\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.ConnectedGreenNId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.ConnectedGreenNId","text":"time-ordered N-point Composite Green's function\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.Diagram","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.Diagram","text":"mutable struct Diagram{W}\n\nstruct of a diagram. A diagram of a sum or produce of various subdiagrams.\n\nMembers\n\nhash::Int          : the unique hash number to identify the diagram\nname::Symbol       : name of the diagram\nid::DiagramId      : diagram id \noperator::Operator : operation, support Sum() and Prod()\nfactor::W          : additional factor of the diagram\nsubdiagram::Vector{Diagram{W}}   : vector of sub-diagrams\nweight::W          : weight of the diagram\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.DiagramId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.DiagramId","text":"abstract type DiagramId end\n\nThe abstract type of all diagrams/subdiagrams/bare propagators\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.GreenNId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.GreenNId","text":"time-ordered N-point Composite Green's function\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.PropagatorId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.PropagatorId","text":"abstract type PropagatorId <: DiagramId end\n\nThe abstract type of all bare propagators\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.derivative-Union{Tuple{ID}, Tuple{Union{Tuple, AbstractVector}, Type{ID}, Int64}} where ID<:PropagatorId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.derivative","text":"function derivative(diags::Union{Diagram,Tuple,AbstractVector}, ::Type{ID}, order::Int) where {ID<:PropagatorId}\n\nAutomatic differentiation derivative on the diagrams\n\nArguments\n\ndiags      : diagrams to take derivative\nID         : DiagramId to apply the differentiation\norder::Int : derivative order\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.derivative-Union{Tuple{ID}, Tuple{W}, Tuple{Union{Tuple, AbstractVector}, Type{ID}}} where {W, ID<:PropagatorId}","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.derivative","text":"function derivative(diags::Union{Tuple,AbstractVector}, ::Type{ID}; index::Int=index(ID)) where {W,ID<:PropagatorId}\nfunction derivative(diags::Vector{Diagram{W}}, ::Type{ID}; index::Int=index(ID)) where {W,ID<:PropagatorId}\n\nAutomatic differentiation derivative on the diagrams\n\nArguments\n\ndiags     : diagrams to take derivative\nID        : DiagramId to apply the differentiation\nindex     : index of the id.order array element to increase the order\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.plot_tree-Tuple{Diagram}","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.plot_tree","text":"function plot_tree(diag::Diagram; verbose = 0, maxdepth = 6)\n\nVisualize the diagram tree using ete3 python package\n\n#Arguments\n\ndiag        : the Diagram struct to visualize\nverbose=0   : the amount of information to show\nmaxdepth=6  : deepest level of the diagram tree to show\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.removeDuplicatedLeaves!-Union{Tuple{Array{Diagram{W}, 1}}, Tuple{W}} where W","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.removeDuplicatedLeaves!","text":"removeDuplicatedLeaves!(diags::AbstractVector; verbose = 0)\n\nremove duplicated nodes such as:  ---> ver4 ---> InteractionId. Leaf will not be touched!\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.removeHatreeFock!-Union{Tuple{Diagram{W}}, Tuple{W}} where W","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.removeHatreeFock!","text":"function removeHatreeFock!(diag::Diagram{W}) where {W}\nfunction removeHatreeFock!(diags::Union{Tuple,AbstractVector})\n\nRemove the Hatree-Fock insertions that without any derivatives on the propagator and the interaction.\n\nArguments\n\ndiags      : diagrams to remove the Fock insertion\n\nRemarks\n\nThe operations removeHatreeFock! and taking derivatives doesn't commute with each other! \nIf the input diagram is a Hatree-Fock diagram, then the overall weight will become zero! \nThe return value is always nothing\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.removeOneChildParent!-Union{Tuple{Array{Diagram{W}, 1}}, Tuple{W}} where W","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.removeOneChildParent!","text":"removeOneChildParent!(diags::AbstractVector; verbose = 0)\n\nremove duplicated nodes such as:  ---> ver4 ---> InteractionId. Leaf will not be touched!\n\n\n\n\n\n","category":"method"}]
}
