var documenterSearchIndex = {"docs":
[{"location":"lib/exprtree/#Diagrams-as-an-Expression-Tree","page":"Diagrams as an Expression Tree","title":"Diagrams as an Expression Tree","text":"","category":"section"},{"location":"lib/exprtree/#API","page":"Diagrams as an Expression Tree","title":"API","text":"","category":"section"},{"location":"lib/exprtree/","page":"Diagrams as an Expression Tree","title":"Diagrams as an Expression Tree","text":"Modules = [FeynmanDiagram.ExprTree]","category":"page"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.CachedPool","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.CachedPool","text":"struct CachedPool{O,T}\n\n    Use this pool to host the objects that are heavy to evaluate so that one wants to cache their status.\n    The user should defines a compare\n\nMembers\n\nname::Symbol : name of the pool\nobject::O    : object\ncurrent::T      : current status\nnew::T       : the new status wants to assign later\nversion::Int128 : the current version\nexcited::Bool   : if set to excited, then the current status needs to be replaced with the new status\n\n\n\n\n\n","category":"type"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.Diagrams","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.Diagrams","text":"mutable struct Diagrams{V,P,PARA,F,W}\n\nDiagram Object represents a set of Feynman diagrams in a tree (forest) structure\n\nMembers\n\nbasisPool::V      : Tuple of pools of cached basis  in a format of (BasisPool1, BasisPool2, ...)\npropagatorPool::P : Tuple of pools of cached propagators in a format of (PropagatorPool1, PropagatorPool2, ...)\nnodePool::Pool{Node{PARA,F},W} : Pool of the nodes in the diagram tree\nroot::Vector{Int} : indices of the cached nodes that are the root(s) of the diagram tree. Each element corresponds to one root.\n\n\n\n\n\n","category":"type"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.LoopPool","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.LoopPool","text":"struct LoopPool{T}\n\nPool of loop basis. Each loop basis corresponds to a loop variable.\nA loop variable is a linear combination of N independent loops. The combination coefficients is what we call a loop basis.\nFor example, if a loop is a momentum K, then\n\nvaribale_i = K_1*basis[1, i] + K_2*basis[2, i] + K_3*basis[3, i] + ...\n\nMembers\n\nname::Symbol : name of the pool\ndim::Int     : dimension of a loop variable (for example, the dimension of a momentum-frequency loop variable is (d+1) where d is the spatial dimension)\nN::Int       : number of independent loops (dimension of loop basis)\nbasis::Matrix{T}    : Matrix of (N x Nb) that stores the loop basis, where Nb is the number of loop basis (or number of loop variables).\ncurrent::Matrix{T}  : Matrix of (dim x Nb) that stores the loop variables, where Nb is the number of loop basis (or number of loop variables).\n\n\n\n\n\n","category":"type"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.Node","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.Node","text":"mutable struct Node{PARA,F}\n\nNode Object, which is the building block of the diagram tree. Each node is a collection of CACHED proapgator objects and other child CACHED node objects\n\nMembers\n\npara::PARA     : user-defined parameters, which will be used to evaluate the factor and the weight of the node (e.g., if the node represents a vertex function, then the parameter may be the momentum basis of the external legs)\noperation::Int : #1: multiply, 2: add, ...\nfactor::F      : additional factor of the node\ncomponents::Vector{Vector{Int}}  : Index to the cached propagators stored in certain pools. Each Vector{Int} is for one kind of propagator.\nchildNodes::Vector{Int}  : Indices to the cached nodes stored in certain pool. They are the child of the current node in the diagram tree.\nparent::Int : Index to the cached nodes which is the parent of the current node.\n\n\n\n\n\n","category":"type"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.Propagator","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.Propagator","text":"mutable struct Propagator{PARA,F}\n\n Object of all kinds of propagators (many-body Green's functions, interactions, vertex functions, ...)\n\nMembers\n\npara::PARA : User-defined parameters, which will be used to evaluate the factor and the weight of the propagator\norder::Int : The order of the propagators (for example, in a Feynman diagrammatic expansion, the one-body Green's function usually has order zero, and an interaction usually has order one)\nfactor::F : Additional factor of the propagator\nbasis::Vector{Int} : Index to the cached basis stored in certain pool. They are essentail for the weight evaluation of the propagator (the first index for the first basis type, the second index for the second basis type, etc.). \n\n\n\n\n\n","category":"type"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.addNode!","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.addNode!","text":"function addNode!(diag::Diagrams, operator, name, factor = 1.0; propagator = nothing, child = [], parent = 0, para = nothing)\n\nAdd a node into the diagram tree.\n\nArguments\n\ndiag::Diagrams : Diagram tree.\noperator::Int  : #1: multiply, 2: add, ...\nname           : name of the node\nfactor = 1.0   : Factor of the node\npropagator = nothing  : Index to the cached propagators stored in certain pools. It should be in the format of Vector{Vector{Int}}, where each Vector{Int} is for one kind of propagator.\nchild = []        : Indices to the cached nodes stored in certain pool. They are the child of the current node in the diagram tree. It should be in the format of Vector{Int}.\npara = nothing    : Additional paramenter required to evaluate the node. Set to nothing by default.\n\n\n\n\n\n","category":"function"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.addNodeByName!","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.addNodeByName!","text":"function addNodeByName(diag::Diagrams, operator, name = :none; child = [], factor = 1.0, parent = 0, para = nothing, kwargs...)\n\nAn alternative way to add node. Instead of providing the components vector, one specify the propagators in kwargs.\n\nArguments\n\ndiag::Diagrams : Diagram tree.\noperator::Int  : #1: multiply, 2: add, ...\nname           : name of the node\nfactor = 1.0   : Factor of the node\nchild = []        : Indices to the cached nodes stored in certain pool. They are the child of the current node in the diagram tree. It should be in the format of Vector{Int}.\npara = nothing    : Additional paramenter required to evaluate the node. Set to nothing by default.\nkwargs...      : Accept arbitrary pair of parameters as: PropagatorPoolName = [index of the propagator1, index of the propagator2, ...]\n\n\n\n\n\n","category":"function"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.addPropagator!","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.addPropagator!","text":"function addPropagator!(diag::Diagrams, index::Int, order::Int, name, factor = 1; site = [], loop = nothing, para = nothing)\n\nAdd a propagator into the diagram tree.\n\nArguments\n\ndiag::Diagrams : Diagram tree.\nindex::Int     : Index of the propagator in the diagram tree.\norder::Int     : Order of the propagator.\nname = :none   : name of the propagator.\nfactor = 1     : Factor of the propagator.\nsite = []      : site basis (e.g, time and space coordinate) of the propagator.\nloop = nothing : loop basis (e.g, momentum and frequency) of the propagator.\npara = nothing : Additional paramenter required to evaluate the propagator.\n\n\n\n\n\n","category":"function"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.addPropagator!-2","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.addPropagator!","text":"function addPropagator!(diag::Diagrams, poolName::Symbol, order::Int, name, factor = 1; site = [], loop = nothing, para = nothing)\n\nAdd a propagator into the diagram tree referenced by the pool name.\n\nArguments\n\ndiag::Diagrams : Diagram tree.\npoolName::Symbol : name of the propagator pool\norder::Int     : Order of the propagator.\nname = :none   : name of the propagator.\nfactor = 1     : Factor of the propagator.\nsite = []      : site basis (e.g, time and space coordinate) of the propagator.\nloop = nothing : loop basis (e.g, momentum and frequency) of the propagator.\npara = nothing : Additional paramenter required to evaluate the propagator.\n\n\n\n\n\n","category":"function"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.getNode-Tuple{FeynmanDiagram.ExprTree.Diagrams, Int64}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.getNode","text":"function getNode(diag::Diagrams, nidx::Int)\n\nget Node in the diag with the index nidx.\n\n\n\n\n\n","category":"method"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.getNodeWeight-Tuple{FeynmanDiagram.ExprTree.Diagrams, Int64}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.getNodeWeight","text":"function getNodeWeight(diag::Diagrams, nidx::Int)\n\nget Node weight in the diag with the index nidx.\n\n\n\n\n\n","category":"method"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.showTree-Tuple{FeynmanDiagram.ExprTree.Diagrams, Int64}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.showTree","text":"showTree(diag::Diagrams, _root = diag.root[end]; verbose = 0, depth = 999)\n\nVisualize the diagram tree using ete3 python package\n\n#Arguments\n\ndiag: the Diagrams struct to visualize\n_root: the index of the root node to visualize\nverbose=0: the amount of information to show\ndepth=999: deepest level of the diagram tree to show\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#Parquet-Algorithm-to-Build-Diagrams","page":"Parquet Algorithm to Build Diagrams","title":"Parquet Algorithm to Build Diagrams","text":"","category":"section"},{"location":"lib/parquet/#API","page":"Parquet Algorithm to Build Diagrams","title":"API","text":"","category":"section"},{"location":"lib/parquet/","page":"Parquet Algorithm to Build Diagrams","title":"Parquet Algorithm to Build Diagrams","text":"Modules = [FeynmanDiagram.Parquet]","category":"page"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.ParquetBlocks","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.ParquetBlocks","text":"struct ParquetBlocks\n\nThe channels of the left and right sub-vertex4 of a bubble diagram in the parquet equation\n\n#Members\n\nphi   : channels of left sub-vertex for the particle-hole and particle-hole-exchange bubbles\nppi   : channels of left sub-vertex for the particle-particle bubble\nΓ4   : channels of right sub-vertex of all channels\n\n\n\n\n\n","category":"type"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.green","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.green","text":"green(para, extK = DiagTree.getK(para.totalLoopNum, 1), extT = para.hasTau ? (1, 2) : (0, 0), subdiagram = false;\n    name = :G, resetuid = false)\n\nBuild composite Green's function.\nBy definition, para.firstTauIdx is the first Tau index of the left most self-energy subdiagram.\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nextT: [Tau index of the left leg, Tau index of the right leg]\nsubdiagram      : a sub-vertex or not\nname            : name of the diagram\nresetuid        : restart uid count from 1\n\nOutput\n\nA Diagram object or nothing if the Green's function is illegal. \n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.polarization","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.polarization","text":"function polarization(para, extK = DiagTree.getK(para.totalLoopNum, 1), subdiagram = false; name = :Π, resetuid = false)\n\nGenerate polarization diagrams using Parquet Algorithm.\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nresetuid        : restart uid count from 1\n\nOutput\n\nA DataFrame with fields :response, :diagram, :hash. \nAll polarization share the same external Tau index. With imaginary-time variables, they are extT = (para.firstTauIdx, para.firstTauIdx+1)\n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.sigma","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.sigma","text":"function sigma(para, extK = DiagTree.getK(para.totalLoopNum, 1), subdiagram = false; name = :Σ, resetuid = false)\n\nBuild sigma diagram. \nWhen sigma is created as a subdiagram, then no Fock diagram is generated if para.filter contains NoFock, and no sigma diagram is generated if para.filter contains Girreducible\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nsubdiagram      : a sub-vertex or not\nname            : name of the diagram\nresetuid        : restart uid count from 1\n\nOutput\n\nA DataFrame with fields :type, :extT, :diagram, :hash\nAll sigma share the same incoming Tau index, but not the outgoing one\n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.vertex3","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.vertex3","text":"function vertex3(para, extK = [DiagTree.getK(para.totalLoopNum, 1), DiagTree.getK(para.totalLoopNum, 2)],\n    subdiagram = false; name = :Γ3, chan = [PHr, PHEr, PPr, Alli], resetuid = false)\n\nGenerate 3-vertex diagrams using Parquet Algorithm.\nWith imaginary-time variables, all vertex3 generated has the same bosonic Tidx ``extT[1]=para.firstTauIdx`` and the incoming fermionic Tidx ``extT[2]=para.firstTauIdx+1``.\n\n#Arguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loops as a vector [bosonic leg, fermionic in, fermionic out]. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nchan            : vector of channels of the current 4-vertex. \nresetuid        : restart uid count from 1\n\nOutput\n\nA DataFrame with fields :response, :extT, :diagram, :hash. \n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.vertex4","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.vertex4","text":"vertex4(para::GenericPara,\n    extK = [DiagTree.getK(para.totalLoopNum, 1), DiagTree.getK(para.totalLoopNum, 2), DiagTree.getK(para.totalLoopNum, 3)],\n    chan::AbstractVector = [PHr, PHEr, PPr, Alli],\n    subdiagram = false;\n    level = 1, name = :none, resetuid = false,\n    phi_toplevel = ParquetBlocks().phi, ppi_toplevel = ParquetBlocks().ppi, Γ4_toplevel = ParquetBlocks().Γ4)\n\nGenerate 4-vertex diagrams using Parquet Algorithm\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loops as a vector [left in, left out, right in, right out]. \nchan            : vector of channels of the current 4-vertex. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nlevel           : level in the diagram tree\nresetuid        : restart uid count from 1\nphi_toplevel    : channels of left sub-vertex for the particle-hole and particle-hole-exchange of the bubble at level one.\nppi_toplevel    : channels of left sub-vertex for the particle-particle bubble at level one\nΓ4_toplevel     : channels of right sub-vertex for all all bubbles at level one\n\nOutput\n\nA DataFrame with fields :response, :type, :extT, :diagram, :hash\n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#Usage","page":"Parquet Algorithm to Build Diagrams","title":"Usage","text":"","category":"section"},{"location":"lib/parquet/","page":"Parquet Algorithm to Build Diagrams","title":"Parquet Algorithm to Build Diagrams","text":"using FeynmanDiagram\npara = GenericPara(diagType = Ver4Diag, innerLoopNum = 1, hasTau = true);\nParquet.vertex4(para)\n\npara = GenericPara(diagType = Ver3Diag, innerLoopNum = 1, hasTau = true);\nParquet.vertex3(para)\n\npara = GenericPara(diagType = SigmaDiag, innerLoopNum = 1, hasTau = true);\nParquet.sigma(para)\n\npara = GenericPara(diagType = PolarDiag, innerLoopNum = 1, hasTau = true);\nParquet.polarization(para)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FeynmanDiagram","category":"page"},{"location":"#FeynmanDiagram","page":"Home","title":"FeynmanDiagram","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FeynmanDiagram.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [FeynmanDiagram]","category":"page"},{"location":"#FeynmanDiagram.innerTauNum-Tuple{FeynmanDiagram.DiagramType, Any, Any}","page":"Home","title":"FeynmanDiagram.innerTauNum","text":"function innerTauNum(diagType::DiagramType, innerLoopNum, interactionTauNum)\n\ninternal imaginary-time degrees of freedom for a given diagram type and internal loop number.\nFor the vertex functions (self-energy, polarization, vertex3, and vertex4), innerTauNum is equivalent to tauNum.\nFor the Green function, tauNum = innerTauNum + external tauNum\n\n\n\n\n\n","category":"method"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/parquet.md\",\n    \"lib/diagtree.md\",\n    \"lib/exprtree.md\",\n]\nDepth = 2","category":"page"},{"location":"lib/diagtree/#Diagrams-as-an-AbstractTree","page":"Diagrams as an AbstractTree","title":"Diagrams as an AbstractTree","text":"","category":"section"},{"location":"lib/diagtree/#API","page":"Diagrams as an AbstractTree","title":"API","text":"","category":"section"},{"location":"lib/diagtree/","page":"Diagrams as an AbstractTree","title":"Diagrams as an AbstractTree","text":"Modules = [FeynmanDiagram.DiagTree]","category":"page"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.plot_tree-Tuple{Diagram}","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.plot_tree","text":"showTree(diag::Diagrams, _root = diag.root[end]; verbose = 0, depth = 999)\n\nVisualize the diagram tree using ete3 python package\n\n#Arguments\n\ndiag: the Diagrams struct to visualize\n_root: the index of the root node to visualize\nverbose=0: the amount of information to show\ndepth=999: deepest level of the diagram tree to show\n\n\n\n\n\n","category":"method"}]
}
