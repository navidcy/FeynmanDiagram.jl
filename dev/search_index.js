var documenterSearchIndex = {"docs":
[{"location":"manual/interaction/#Interaction/Scattering-Amplitude-Convention","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"","category":"section"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"In general, the interaction (or scattering amplitude) between two spin-12 particles is controlled by only two parameters. Here we briefly review some of the common conventions of the parameters in literature, and show how to map between different conventions.","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"We assume a particle from the left collides with a particle from the right. Due to the interaction between the two particles, one of them scatters to the left, and the other to the right. ","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"We will use the index alphabetagammadelta to label the left incoming, the left outgoing, the right incoming and the right outgoing particles. We assume four legs associate with four momentum-frequency vectors k_1 k_2 k_3 k_4.","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"There are two possible scatterings: a direct scattering where the two particles don't permutate after the collision, and an exchange scattering where the two particles permutate. Therefore, the total scattering amplitude has two contributions,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v_alphabetagammadelta(1234) = v^d_alphabetagammadelta(1234)+v^e_alphabetagammadelta(1234)","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"where the exchange contribution is different from the direct counterpart up to an exchange of two outgoing legs and an overall particle statistic sign xi =pm 1,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_alphabetagammadelta(1234) = xi v^d_alphadeltagammabeta(1432)","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"where we have abbreviated the momentum-frequency vectors as indices.","category":"page"},{"location":"manual/interaction/#.-Spin-symmetric-and-asymmetric-convention:","page":"Interaction/Scattering-Amplitude Convention","title":"1. Spin symmetric and asymmetric convention:","text":"","category":"section"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"A interaction is split into a term that is independent of the spin (e.g., Coulomb interaction between electrons) and a term with spin dependence (e.g., ferromagnetic/antiferromagnetic interaction). This convention is commonly used in textbooks of Fermi liquid theory.","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^d_alphabetagammadelta(1234) equiv v^s_1234delta_alphabetadelta_gammadelta + v^a_1234 vecsigma_alphabetacdot vecsigma_gammadelta","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"where the superscript d means the scattering is direct.","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"If two particles permute after the collision, then one needs to exchange beta leftrightarrow gamma and other internal variables,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_alphabetagammadelta(1234) = xi v^s_1432delta_alphadeltadelta_gammabeta + xi v^a_1432 vecsigma_alphadeltacdot vecsigma_gammabeta","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_alphabetagammadelta(1234) = xifracv^s_1432+3v^a_14322delta_alphabetadelta_gammadelta + xi fracv^s_1432-v^a_14322 vecsigma_alphabetacdot vecsigma_gammadelta","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"To derive the above equations, we use the identity vecsigma_alphabetacdot vecsigma_gammadelta=2 delta_alpha delta delta_beta gamma-delta_alpha beta delta_gamma delta, which gives the following equations,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"delta_alphadeltadelta_gammabeta=frac12delta_alphabetadelta_gammadelta+frac12vecsigma_alphabetacdot vecsigma_gammadelta","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"and,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"vecsigma_alphadeltacdot vecsigma_gammabeta=frac32delta_alphabetadelta_gammadelta-frac12vecsigma_alphabetacdot vecsigma_gammadelta","category":"page"},{"location":"manual/interaction/#.-Spin-\\uparrow\\uparrow-and-\\uparrow\\downarrow-convention:","page":"Interaction/Scattering-Amplitude Convention","title":"2. Spin uparrowuparrow and uparrowdownarrow convention:","text":"","category":"section"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"An alternative parameterization of the interaction matrix is by specifiying the spin components v_uparrowuparrow equiv v_uparrowuparrowuparrowuparrow and v_uparrowdownarrow equiv v_uparrowuparrowdownarrowdownarrow. They can be derived from v_s and v_a by the simple relation,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^d_uparrowuparrow(1234) = v^s_1234+v^a_1234","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^d_uparrowdownarrow(1234) = v^s_1234-v^a_1234","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"If two particles permute after the collision, the exchange interaction v^e,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_uparrowuparrow(1234) = xifracv^s_1432+3v^a_14322+xifracv^s_1432-v^s_14322 = xi v^s_1432+ xi v^a_1432","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_uparrowdownarrow(1234) = xifracv^s_1432+3v^a_14322-xifracv^s_1432-v^s_14322 = 2 xi v^a_1432","category":"page"},{"location":"lib/exprtree/#Diagrams-as-an-Expression-Tree","page":"Diagrams as an Expression Tree","title":"Diagrams as an Expression Tree","text":"","category":"section"},{"location":"lib/exprtree/#API","page":"Diagrams as an Expression Tree","title":"API","text":"","category":"section"},{"location":"lib/exprtree/","page":"Diagrams as an Expression Tree","title":"Diagrams as an Expression Tree","text":"Modules = [FeynmanDiagram.ExprTree]","category":"page"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.CachedPool","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.CachedPool","text":"struct CachedPool{O,T}\n\n    Use this pool to host the objects that are heavy to evaluate so that one wants to cache their status.\n    The user should defines a compare\n\nMembers\n\nname::Symbol : name of the pool\nobject::O    : object\ncurrent::T      : current status\nnew::T       : the new status wants to assign later\nversion::Int128 : the current version\nexcited::Bool   : if set to excited, then the current status needs to be replaced with the new status\n\n\n\n\n\n","category":"type"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.ExpressionTree","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.ExpressionTree","text":"mutable struct ExpressionTree{V,PARA,F,W}\n\nDiagram Object represents a set of Feynman diagrams in an experssion tree (forest) structure\n\nMembers\n\nname::Symbol                     : Name of the tree\nloopBasis::V                     : Tuple of pools of cached basis  in a format of (BasisPool1, BasisPool2, ...)\nnode::CachedPool{Node{PARA,F},W} : Pool of the nodes in the diagram tree\nroot::Vector{Int}                : indices of the cached nodes that are the root(s) of the diagram tree. Each element corresponds to one root.\n\n\n\n\n\n","category":"type"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.LoopPool","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.LoopPool","text":"struct LoopPool{T}\n\nPool of loop basis. Each loop basis corresponds to a loop variable.\nA loop variable is a linear combination of N independent loops. The combination coefficients is what we call a loop basis.\nFor example, if a loop is a momentum K, then\n\nvaribale_i = K_1*basis[1, i] + K_2*basis[2, i] + K_3*basis[3, i] + ...\n\nMembers\n\nname::Symbol : name of the pool\ndim::Int     : dimension of a loop variable (for example, the dimension of a momentum-frequency loop variable is (d+1) where d is the spatial dimension)\nN::Int       : number of independent loops (dimension of loop basis)\nbasis::Matrix{T}    : Matrix of (N x Nb) that stores the loop basis, where Nb is the number of loop basis (or number of loop variables).\ncurrent::Matrix{T}  : Matrix of (dim x Nb) that stores the loop variables, where Nb is the number of loop basis (or number of loop variables).\n\n\n\n\n\n","category":"type"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.Node","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.Node","text":"mutable struct Node{PARA,F}\n\nNode Object, which is the building block of the diagram tree. Each node is a collection of CACHED proapgator objects and other child CACHED node objects\n\nMembers\n\npara::PARA     : user-defined parameters, which will be used to evaluate the factor and the weight of the node (e.g., if the node represents a vertex function, then the parameter may be the momentum basis of the external legs)\noperation::Int : #1: multiply, 2: add, ...\nfactor::F      : additional factor of the node\ncomponents::Vector{Vector{Int}}  : Index to the cached propagators stored in certain pools. Each Vector{Int} is for one kind of propagator.\nchildNodes::Vector{Int}  : Indices to the cached nodes stored in certain pool. They are the child of the current node in the diagram tree.\nparent::Int : Index to the cached nodes which is the parent of the current node.\n\n\n\n\n\n","category":"type"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.addnode!-Union{Tuple{W}, Tuple{F}, Tuple{PARA}, Tuple{V}, Tuple{ExpressionTree{V, PARA, F, W}, Any, Any, Union{Tuple, AbstractVector}}, Tuple{ExpressionTree{V, PARA, F, W}, Any, Any, Union{Tuple, AbstractVector}, Any}} where {V, PARA, F, W}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.addnode!","text":"function addnode!(diag::ExpressionTree{V,PARA,F,W}, operator, name, children::Union{Tuple, AbstractVector}, factor = 1.0; para = nothing) where {V,PARA,F,W}\n\nAdd a node into the expression tree.\n\nArguments\n\ndiag::ExpressionTree  : diagrammatic experssion tree.\noperator::Int         : #1: multiply, 2: add, ...\nname                  : name of the node\nchildren              : Indices to the cached nodes stored in certain pool. They are the child of the current node in the diagram tree. It should be in the format of Vector{Int}.\nfactor = 1.0          : Factor of the node\npara = nothing        : Additional paramenter required to evaluate the node. Set to nothing by default.\n\n\n\n\n\n","category":"method"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.addpropagator!-Union{Tuple{W}, Tuple{F}, Tuple{PARA}, Tuple{V}, Tuple{ExpressionTree{V, PARA, F, W}, Any}, Tuple{ExpressionTree{V, PARA, F, W}, Any, Any}} where {V, PARA, F, W}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.addpropagator!","text":"function addPropagator!(diag::ExpressionTree, name, factor = 1.0; site = [], loop = nothing, para = nothing, order::Int = 0)\n\nAdd a propagator into the diagram tree.\n\nArguments\n\ndiag           : diagrammatic experssion tree.\norder::Int = 0 : Order of the propagator.\nname = :none   : name of the propagator.\nfactor = 1     : Factor of the propagator.\nsite = []      : site basis (e.g, time and space coordinate) of the propagator.\nloop = nothing : loop basis (e.g, momentum and frequency) of the propagator.\npara = nothing : Additional paramenter required to evaluate the propagator.\n\n\n\n\n\n","category":"method"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.getNode-Tuple{Any, Int64}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.getNode","text":"function getNode(diag::Diagrams, nidx::Int)\n\nget Node in the diag with the index nidx.\n\n\n\n\n\n","category":"method"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.getNodeWeight-Tuple{Any, Int64}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.getNodeWeight","text":"function getNodeWeight(tree, nidx::Int)\n\nget Node weight in the diagram experssion tree with the index nidx.\n\n\n\n\n\n","category":"method"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.showTree-Tuple{ExpressionTree, Int64}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.showTree","text":"showTree(diag::Diagrams, _root = diag.root[end]; verbose = 0, depth = 999)\n\nVisualize the diagram tree using ete3 python package\n\n#Arguments\n\ndiag: the Diagrams struct to visualize\n_root: the index of the root node to visualize\nverbose=0: the amount of information to show\ndepth=999: deepest level of the diagram tree to show\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#Parquet-Algorithm-to-Build-Diagrams","page":"Parquet Algorithm to Build Diagrams","title":"Parquet Algorithm to Build Diagrams","text":"","category":"section"},{"location":"lib/parquet/#API","page":"Parquet Algorithm to Build Diagrams","title":"API","text":"","category":"section"},{"location":"lib/parquet/","page":"Parquet Algorithm to Build Diagrams","title":"Parquet Algorithm to Build Diagrams","text":"Modules = [FeynmanDiagram.Parquet]","category":"page"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.ParquetBlocks","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.ParquetBlocks","text":"struct ParquetBlocks\n\nThe channels of the left and right sub-vertex4 of a bubble diagram in the parquet equation\n\n#Members\n\nphi   : channels of left sub-vertex for the particle-hole and particle-hole-exchange bubbles\nppi   : channels of left sub-vertex for the particle-particle bubble\nΓ4   : channels of right sub-vertex of all channels\n\n\n\n\n\n","category":"type"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.green","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.green","text":"green(para, extK = DiagTree.getK(para.totalLoopNum, 1), extT = para.hasTau ? (1, 2) : (0, 0), subdiagram = false;\n    name = :G, resetuid = false)\n\nBuild composite Green's function.\nBy definition, para.firstTauIdx is the first Tau index of the left most self-energy subdiagram.\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nextT: [Tau index of the left leg, Tau index of the right leg]\nsubdiagram      : a sub-vertex or not\nname            : name of the diagram\nresetuid        : restart uid count from 1\n\nOutput\n\nA Diagram object or nothing if the Green's function is illegal. \n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.polarization","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.polarization","text":"function polarization(para, extK = DiagTree.getK(para.totalLoopNum, 1), subdiagram = false; name = :Π, resetuid = false)\n\nGenerate polarization diagrams using Parquet Algorithm.\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nresetuid        : restart uid count from 1\n\nOutput\n\nA DataFrame with fields :response, :diagram, :hash. \nAll polarization share the same external Tau index. With imaginary-time variables, they are extT = (para.firstTauIdx, para.firstTauIdx+1)\n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.sigma","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.sigma","text":"function sigma(para, extK = DiagTree.getK(para.totalLoopNum, 1), subdiagram = false; name = :Σ, resetuid = false)\n\nBuild sigma diagram. \nWhen sigma is created as a subdiagram, then no Fock diagram is generated if para.filter contains NoFock, and no sigma diagram is generated if para.filter contains Girreducible\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nsubdiagram      : a sub-vertex or not\nname            : name of the diagram\nresetuid        : restart uid count from 1\n\nOutput\n\nA DataFrame with fields :type, :extT, :diagram, :hash\nAll sigma share the same incoming Tau index, but not the outgoing one\n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.vertex3","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.vertex3","text":"function vertex3(para, extK = [DiagTree.getK(para.totalLoopNum, 1), DiagTree.getK(para.totalLoopNum, 2)],\n    subdiagram = false; name = :Γ3, chan = [PHr, PHEr, PPr, Alli], resetuid = false)\n\nGenerate 3-vertex diagrams using Parquet Algorithm.\nWith imaginary-time variables, all vertex3 generated has the same bosonic Tidx ``extT[1]=para.firstTauIdx`` and the incoming fermionic Tidx ``extT[2]=para.firstTauIdx+1``.\n\n#Arguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loops as a vector [bosonic leg, fermionic in, fermionic out]. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nchan            : vector of channels of the current 4-vertex. \nresetuid        : restart uid count from 1\n\nOutput\n\nA DataFrame with fields :response, :extT, :diagram, :hash. \n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.vertex4","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.vertex4","text":"vertex4(para::GenericPara,\n    extK = [DiagTree.getK(para.totalLoopNum, 1), DiagTree.getK(para.totalLoopNum, 2), DiagTree.getK(para.totalLoopNum, 3)],\n    chan::AbstractVector = [PHr, PHEr, PPr, Alli],\n    subdiagram = false;\n    level = 1, name = :none, resetuid = false,\n    phi_toplevel = ParquetBlocks().phi, ppi_toplevel = ParquetBlocks().ppi, Γ4_toplevel = ParquetBlocks().Γ4)\n\nGenerate 4-vertex diagrams using Parquet Algorithm\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loops as a vector [left in, left out, right in, right out]. \nchan            : vector of channels of the current 4-vertex. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nlevel           : level in the diagram tree\nresetuid        : restart uid count from 1\nphi_toplevel    : channels of left sub-vertex for the particle-hole and particle-hole-exchange of the bubble at level one.\nppi_toplevel    : channels of left sub-vertex for the particle-particle bubble at level one\nΓ4_toplevel     : channels of right sub-vertex for all all bubbles at level one\n\nOutput\n\nA DataFrame with fields :response, :type, :extT, :diagram, :hash\n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#Usage","page":"Parquet Algorithm to Build Diagrams","title":"Usage","text":"","category":"section"},{"location":"lib/parquet/","page":"Parquet Algorithm to Build Diagrams","title":"Parquet Algorithm to Build Diagrams","text":"using FeynmanDiagram\npara = GenericPara(diagType = Ver4Diag, innerLoopNum = 1, hasTau = true);\nParquet.vertex4(para)\n\npara = GenericPara(diagType = Ver3Diag, innerLoopNum = 1, hasTau = true);\nParquet.vertex3(para)\n\npara = GenericPara(diagType = SigmaDiag, innerLoopNum = 1, hasTau = true);\nParquet.sigma(para)\n\npara = GenericPara(diagType = PolarDiag, innerLoopNum = 1, hasTau = true);\nParquet.polarization(para)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FeynmanDiagram","category":"page"},{"location":"#FeynmanDiagram","page":"Home","title":"FeynmanDiagram","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FeynmanDiagram.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [FeynmanDiagram]","category":"page"},{"location":"#FeynmanDiagram.innerTauNum-Tuple{FeynmanDiagram.DiagramType, Any, Any}","page":"Home","title":"FeynmanDiagram.innerTauNum","text":"function innerTauNum(diagType::DiagramType, innerLoopNum, interactionTauNum)\n\ninternal imaginary-time degrees of freedom for a given diagram type and internal loop number.\nFor the vertex functions (self-energy, polarization, vertex3, and vertex4), innerTauNum is equivalent to tauNum.\nFor the Green function, tauNum = innerTauNum + external tauNum\n\n\n\n\n\n","category":"method"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/parquet.md\",\n    \"lib/diagtree.md\",\n    \"lib/exprtree.md\",\n]\nDepth = 2","category":"page"},{"location":"lib/diagtree/#Diagrams-as-an-AbstractTree","page":"Diagrams as an AbstractTree","title":"Diagrams as an AbstractTree","text":"","category":"section"},{"location":"lib/diagtree/#API","page":"Diagrams as an AbstractTree","title":"API","text":"","category":"section"},{"location":"lib/diagtree/","page":"Diagrams as an AbstractTree","title":"Diagrams as an AbstractTree","text":"Modules = [FeynmanDiagram.DiagTree]","category":"page"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.BareGreenNId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.BareGreenNId","text":"time-ordered N-point Bare Green's function\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.BareHoppingId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.BareHoppingId","text":"hopping function c⁺c⁻\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.ConnectedGreenNId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.ConnectedGreenNId","text":"time-ordered N-point Composite Green's function\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.Diagram","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.Diagram","text":"mutable struct Diagram{W}\n\nstruct of a diagram. A diagram of a sum or produce of various subdiagrams.\n\nMembers\n\nhash::Int          : the unique hash number to identify the diagram\nname::Symbol       : name of the diagram\nid::DiagramId      : diagram id \noperator::Operator : operation, support Sum() and Prod()\nfactor::W          : additional factor of the diagram\nsubdiagram::Vector{Diagram{W}}   : vector of sub-diagrams\nweight::W          : weight of the diagram\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.DiagramId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.DiagramId","text":"abstract type DiagramId end\n\nThe abstract type of all diagrams/subdiagrams/bare propagators\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.GreenNId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.GreenNId","text":"time-ordered N-point Composite Green's function\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.PropagatorId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.PropagatorId","text":"abstract type PropagatorId <: DiagramId end\n\nThe abstract type of all bare propagators\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.derivative-Union{Tuple{ID}, Tuple{Union{Tuple, AbstractVector, Diagram}, Type{ID}, Int64}} where ID<:PropagatorId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.derivative","text":"function derivative(diags::Union{Diagram,Tuple,AbstractVector}, ::Type{ID}, order::Int) where {ID<:PropagatorId}\n\nAutomatic differentiation derivative on the diagrams\n\nArguments\n\ndiags      : diagrams to take derivative\nID         : DiagramId to apply the differentiation\norder::Int : derivative order\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.derivative-Union{Tuple{ID}, Tuple{Union{Tuple, AbstractVector, Diagram}, Type{ID}}} where ID<:PropagatorId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.derivative","text":"function derivative(diags::Union{Diagram,Tuple,AbstractVector}, ::Type{ID}) where {ID<:PropagatorId}\n\nAutomatic differentiation derivative on the diagrams\n\nArguments\n\ndiags     : diagrams to take derivative\nID        : DiagramId to apply the differentiation\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.plot_tree-Tuple{Diagram}","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.plot_tree","text":"function plot_tree(diag::Diagram; verbose = 0, maxdepth = 6)\n\nVisualize the diagram tree using ete3 python package\n\n#Arguments\n\ndiag        : the Diagram struct to visualize\nverbose=0   : the amount of information to show\nmaxdepth=6  : deepest level of the diagram tree to show\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.removeDuplicatedLeaves!-Tuple{AbstractVector}","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.removeDuplicatedLeaves!","text":"removeDuplicatedLeaves!(diags::AbstractVector; verbose = 0)\n\nremove duplicated nodes such as:  ---> ver4 ---> InteractionId. Leaf will not be touched!\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.removeHatreeFock!-Tuple{Union{Tuple, AbstractVector, Diagram}}","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.removeHatreeFock!","text":"function removeHatreeFock!(diags::Union{Diagram,Tuple,AbstractVector})\n\nRemove the Hatree-Fock insertions that without any derivatives on the propagator and the interaction.\n\nArguments\n\ndiags      : diagrams to remove the Fock insertion\n\nRemarks\n\nThe operations removeHatreeFock! and taking derivatives doesn't commute with each other! \nIf the input diagram is a Hatree-Fock diagram, then the overall weight will become zero! \n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.removeOneChildParent!-Tuple{AbstractVector}","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.removeOneChildParent!","text":"removeOneChildParent!(diags::AbstractVector; verbose = 0)\n\nremove duplicated nodes such as:  ---> ver4 ---> InteractionId. Leaf will not be touched!\n\n\n\n\n\n","category":"method"}]
}
