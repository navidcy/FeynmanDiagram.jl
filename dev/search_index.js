var documenterSearchIndex = {"docs":
[{"location":"lib/builder/#Diagram-Tree-Builder","page":"Diagram Tree Builder","title":"Diagram Tree Builder","text":"","category":"section"},{"location":"lib/builder/","page":"Diagram Tree Builder","title":"Diagram Tree Builder","text":"Modules = [FeynmanDiagram.Builder]","category":"page"},{"location":"lib/builder/#FeynmanDiagram.Builder.innerTauNum-Tuple{FeynmanDiagram.Builder.DiagramType, Any, Any}","page":"Diagram Tree Builder","title":"FeynmanDiagram.Builder.innerTauNum","text":"function innerTauNum(diagType::DiagramType, innerLoopNum, interactionTauNum)\n\ninternal imaginary-time degrees of freedom for a given diagram type and internal loop number.\nFor the vertex functions (self-energy, polarization, vertex3, and vertex4), innerTauNum is equivalent to tauNum.\nFor the Green function, tauNum = innerTauNum + external tauNum\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#Diagram-Tree-Builder-based-on-the-Parquet-Algorithm","page":"Diagram Tree Builder based on the Parquet Algorithm","title":"Diagram Tree Builder based on the Parquet Algorithm","text":"","category":"section"},{"location":"lib/parquet/","page":"Diagram Tree Builder based on the Parquet Algorithm","title":"Diagram Tree Builder based on the Parquet Algorithm","text":"Modules = [FeynmanDiagram.Builder.Parquet]","category":"page"},{"location":"lib/parquet/#FeynmanDiagram.Builder.Parquet.IdxMap","page":"Diagram Tree Builder based on the Parquet Algorithm","title":"FeynmanDiagram.Builder.Parquet.IdxMap","text":"struct IdxMap{_Ver4}\n\nMap left vertex Tpair[lidx], right vertex Tpair[ridx], the shared Green's function G0 and the channel specific Green's function Gx to the top level 4-vertex Tpair[vidx]\n\nArguments\n\nl::_Ver4 : left vertex \nr::_Ver4 : right vertex\nv::_Ver4 : composte vertex\nlidx::Int : left sub-vertex index\nridx::Int : right sub-vertex index\nvidx::Int : composite vertex index\nG0::Green : shared Green's function index\nGx::Green : channel specific Green's function index\n\n\n\n\n\n","category":"type"},{"location":"lib/parquet/#FeynmanDiagram.Builder.Parquet.Ver4","page":"Diagram Tree Builder based on the Parquet Algorithm","title":"FeynmanDiagram.Builder.Parquet.Ver4","text":"function Ver4{W}(para::Para, loopNum = para.internalLoopNum, tidx = 1; chan = para.chan, F = para.F, V = para.V, level = 1, id = [1,]) where {W}\n\nGenerate 4-vertex diagrams using Parquet Algorithm\n\n#Arguments\n\npara: parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nchan: list of channels of the current 4-vertex. \nF   : channels of left sub-vertex for the particle-hole and particle-hole-exchange bubbles\nV   : channels of left sub-vertex for the particle-particle bubble\nAll   : channels of right sub-vertex of all channels\nFouter   : channels of left sub-vertex for the particle-hole and particle-hole-exchange bubbles, only take effect for the outermost bubble\nVouter   : channels of left sub-vertex for the particle-particle bubble, only take effect for the outermost bubble\nAllouter   : channels of right sub-vertex of all channels\nloopNum: momentum loop degrees of freedom of the 4-vertex diagrams\ntidx: the first τ variable index. It will be the τ variable of the left incoming electron for all 4-vertex diagrams\nlevel: level in the diagram tree\nid: the first element will be used as the id of the Ver4. All nodes in the tree will be labeled in preorder depth-first search\n\n#Remark:\n\nAbstractTrees interface is implemented for Ver4. So one can use the API in https://juliacollections.github.io/AbstractTrees.jl/stable/ to manipulate/print the tree structre of Ver4.\nThere are three different methods to print/visualize the tree structre: \n\nprint_tree(ver4::Ver4) or print_tree(bub::Bubble) to print the tree to terminal. This function is provided by AbstractTrees API. \nnewick(ver4::Ver4) or newick(bub::Bubble) to serilize the tree to a newick format string. You may save the string to a text file, then visualize it with a newick format visualizer application. \nshowTree(ver4::Ver4) to visualize the tree using the python package ete3. You have to install ete3 properly to use this function.\n\n\n\n\n\n","category":"type"},{"location":"lib/parquet/#FeynmanDiagram.Builder.Parquet.buildG","page":"Diagram Tree Builder based on the Parquet Algorithm","title":"FeynmanDiagram.Builder.Parquet.buildG","text":"function buildG(para, externLoop, extT, subdiagram = false; F = [I, U, S], V = [I, T, U], All = union(F, V), diag = newDiagTree(para, :G))\n\nBuild composite Green's function.\nBy definition, para.firstTauIdx is the first Tau index of the left most self-energy subdiagram.\n\nextT: [Tau index of the left leg, Tau index of the right leg]\n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.Builder.Parquet.buildSigma","page":"Diagram Tree Builder based on the Parquet Algorithm","title":"FeynmanDiagram.Builder.Parquet.buildSigma","text":"function buildSigma(para, externLoop; F = [I, U, S], V = [I, T, U], All = union(F, V), diag = newDiagTree(para, :Sigma), subdiagram = false)\n\nbuild sigma diagram. \nWhen sigma is created as a subdiagram, then no Fock diagram is generated if para.filter contains NoFock, and no sigma diagram is generated if para.filter contains Girreducible\n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.Builder.Parquet.buildVer4","page":"Diagram Tree Builder based on the Parquet Algorithm","title":"FeynmanDiagram.Builder.Parquet.buildVer4","text":"function buildVer4(para, LegK, chan, F, V, All = union(F, V);\n    Fouter = F, Vouter = V, Allouter = All, factor = 1.0, diag = newDiagTree(para, Tuple{Int,Int,Int,Int}, :Ver4))\n\nbuild DiagTree for the one-particle-irreducible 4-point vertex function using the parquet algorithm\n\nArguments:\n\nweightType   : type of the weight of the propagators and the vertex functions\npara         : parameters to generate the diagram tree\nLegK         : momentum basis of external legs, only three of them are expected: [left in, left out, right in], the dimension of each legK is called loopBasis dimension.\n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.Builder.Parquet.newick-Tuple{FeynmanDiagram.Builder.Parquet.Bubble}","page":"Diagram Tree Builder based on the Parquet Algorithm","title":"FeynmanDiagram.Builder.Parquet.newick","text":"convert Bubble tree struct to a string in the newick format\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#FeynmanDiagram.Builder.Parquet.newick-Tuple{FeynmanDiagram.Builder.Parquet.Ver4}","page":"Diagram Tree Builder based on the Parquet Algorithm","title":"FeynmanDiagram.Builder.Parquet.newick","text":"convert Ver4 tree struct to a string in the newick format\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#FeynmanDiagram.Builder.Parquet.showTree-Tuple{Any}","page":"Diagram Tree Builder based on the Parquet Algorithm","title":"FeynmanDiagram.Builder.Parquet.showTree","text":"showTree(ver4, para::Para; verbose=0, depth=999)\n\nVisualize the diagram tree using ete3 python package\n\n#Arguments\n\nver4: the 4-vertex diagram tree to visualize\npara: parameters\nverbose=0: the amount of information to show\ndepth=999: deepest level of the diagram tree to show\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FeynmanDiagram","category":"page"},{"location":"#FeynmanDiagram","page":"Home","title":"FeynmanDiagram","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FeynmanDiagram.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [FeynmanDiagram]","category":"page"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/parquet.md\",\n    \"lib/builder.md\",\n    \"lib/diagtree.md\"\n]\nDepth = 2","category":"page"},{"location":"lib/diagtree/#Expression-Tree-Representation-of-Feynman-Diagrams","page":"Expression Tree Representation of Feynman Diagrams","title":"Expression Tree Representation of Feynman Diagrams","text":"","category":"section"},{"location":"lib/diagtree/","page":"Expression Tree Representation of Feynman Diagrams","title":"Expression Tree Representation of Feynman Diagrams","text":"Modules = [FeynmanDiagram.DiagTree]","category":"page"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.CachedPool","page":"Expression Tree Representation of Feynman Diagrams","title":"FeynmanDiagram.DiagTree.CachedPool","text":"struct CachedPool{O,T}\n\n    Use this pool to host the objects that are heavy to evaluate so that one wants to cache their status.\n    The user should defines a compare\n\nMembers\n\nname::Symbol : name of the pool\nobject::O    : object\ncurrent::T      : current status\nnew::T       : the new status wants to assign later\nversion::Int128 : the current version\nexcited::Bool   : if set to excited, then the current status needs to be replaced with the new status\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.Diagrams","page":"Expression Tree Representation of Feynman Diagrams","title":"FeynmanDiagram.DiagTree.Diagrams","text":"mutable struct Diagrams{V,P,PARA,F,W}\n\nDiagram Object represents a set of Feynman diagrams in a tree (forest) structure\n\nMembers\n\nbasisPool::V      : Tuple of pools of cached basis  in a format of (BasisPool1, BasisPool2, ...)\npropagatorPool::P : Tuple of pools of cached propagators in a format of (PropagatorPool1, PropagatorPool2, ...)\nnodePool::Pool{Node{PARA,F},W} : Pool of the nodes in the diagram tree\nroot::Vector{Int} : indices of the cached nodes that are the root(s) of the diagram tree. Each element corresponds to one root.\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.LoopPool","page":"Expression Tree Representation of Feynman Diagrams","title":"FeynmanDiagram.DiagTree.LoopPool","text":"struct LoopPool{T}\n\nPool of loop basis. Each loop basis corresponds to a loop variable.\nA loop variable is a linear combination of N independent loops. The combination coefficients is what we call a loop basis.\nFor example, if a loop is a momentum K, then\n\nvaribale_i = K_1*basis[1, i] + K_2*basis[2, i] + K_3*basis[3, i] + ...\n\nMembers\n\nname::Symbol : name of the pool\ndim::Int     : dimension of a loop variable (for example, the dimension of a momentum-frequency loop variable is (d+1) where d is the spatial dimension)\nN::Int       : number of independent loops (dimension of loop basis)\nbasis::Matrix{T}    : Matrix of (N x Nb) that stores the loop basis, where Nb is the number of loop basis (or number of loop variables).\ncurrent::Matrix{T}  : Matrix of (dim x Nb) that stores the loop variables, where Nb is the number of loop basis (or number of loop variables).\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.Node","page":"Expression Tree Representation of Feynman Diagrams","title":"FeynmanDiagram.DiagTree.Node","text":"mutable struct Node{PARA,F}\n\nNode Object, which is the building block of the diagram tree. Each node is a collection of CACHED proapgator objects and other child CACHED node objects\n\nMembers\n\npara::PARA     : user-defined parameters, which will be used to evaluate the factor and the weight of the node (e.g., if the node represents a vertex function, then the parameter may be the momentum basis of the external legs)\noperation::Int : #1: multiply, 2: add, ...\nfactor::F      : additional factor of the node\ncomponents::Vector{Vector{Int}}  : Index to the cached propagators stored in certain pools. Each Vector{Int} is for one kind of propagator.\nchildNodes::Vector{Int}  : Indices to the cached nodes stored in certain pool. They are the child of the current node in the diagram tree.\nparent::Int : Index to the cached nodes which is the parent of the current node.\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.Propagator","page":"Expression Tree Representation of Feynman Diagrams","title":"FeynmanDiagram.DiagTree.Propagator","text":"mutable struct Propagator{PARA,F}\n\n Object of all kinds of propagators (many-body Green's functions, interactions, vertex functions, ...)\n\nMembers\n\npara::PARA : User-defined parameters, which will be used to evaluate the factor and the weight of the propagator\norder::Int : The order of the propagators (for example, in a Feynman diagrammatic expansion, the one-body Green's function usually has order zero, and an interaction usually has order one)\nfactor::F : Additional factor of the propagator\nbasis::Vector{Int} : Index to the cached basis stored in certain pool. They are essentail for the weight evaluation of the propagator (the first index for the first basis type, the second index for the second basis type, etc.). \n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.addNode!","page":"Expression Tree Representation of Feynman Diagrams","title":"FeynmanDiagram.DiagTree.addNode!","text":"function addNode!(diag::Diagrams, operator, name, factor = 1.0; propagator = nothing, child = [], parent = 0, para = nothing)\n\nAdd a node into the diagram tree.\n\nArguments\n\ndiag::Diagrams : Diagram tree.\noperator::Int  : #1: multiply, 2: add, ...\nname           : name of the node\nfactor = 1.0   : Factor of the node\npropagator = nothing  : Index to the cached propagators stored in certain pools. It should be in the format of Vector{Vector{Int}}, where each Vector{Int} is for one kind of propagator.\nchild = []        : Indices to the cached nodes stored in certain pool. They are the child of the current node in the diagram tree. It should be in the format of Vector{Int}.\npara = nothing    : Additional paramenter required to evaluate the node. Set to nothing by default.\n\n\n\n\n\n","category":"function"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.addNodeByName!","page":"Expression Tree Representation of Feynman Diagrams","title":"FeynmanDiagram.DiagTree.addNodeByName!","text":"function addNodeByName(diag::Diagrams, operator, name = :none; child = [], factor = 1.0, parent = 0, para = nothing, kwargs...)\n\nAn alternative way to add node. Instead of providing the components vector, one specify the propagators in kwargs.\n\nArguments\n\ndiag::Diagrams : Diagram tree.\noperator::Int  : #1: multiply, 2: add, ...\nname           : name of the node\nfactor = 1.0   : Factor of the node\nchild = []        : Indices to the cached nodes stored in certain pool. They are the child of the current node in the diagram tree. It should be in the format of Vector{Int}.\npara = nothing    : Additional paramenter required to evaluate the node. Set to nothing by default.\nkwargs...      : Accept arbitrary pair of parameters as: PropagatorPoolName = [index of the propagator1, index of the propagator2, ...]\n\n\n\n\n\n","category":"function"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.addPropagator!","page":"Expression Tree Representation of Feynman Diagrams","title":"FeynmanDiagram.DiagTree.addPropagator!","text":"function addPropagator!(diag::Diagrams, poolName::Symbol, order::Int, name, factor = 1; site = [], loop = nothing, para = nothing)\n\nAdd a propagator into the diagram tree referenced by the pool name.\n\nArguments\n\ndiag::Diagrams : Diagram tree.\npoolName::Symbol : name of the propagator pool\norder::Int     : Order of the propagator.\nname = :none   : name of the propagator.\nfactor = 1     : Factor of the propagator.\nsite = []      : site basis (e.g, time and space coordinate) of the propagator.\nloop = nothing : loop basis (e.g, momentum and frequency) of the propagator.\npara = nothing : Additional paramenter required to evaluate the propagator.\n\n\n\n\n\n","category":"function"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.addPropagator!-2","page":"Expression Tree Representation of Feynman Diagrams","title":"FeynmanDiagram.DiagTree.addPropagator!","text":"function addPropagator!(diag::Diagrams, index::Int, order::Int, name, factor = 1; site = [], loop = nothing, para = nothing)\n\nAdd a propagator into the diagram tree.\n\nArguments\n\ndiag::Diagrams : Diagram tree.\nindex::Int     : Index of the propagator in the diagram tree.\norder::Int     : Order of the propagator.\nname = :none   : name of the propagator.\nfactor = 1     : Factor of the propagator.\nsite = []      : site basis (e.g, time and space coordinate) of the propagator.\nloop = nothing : loop basis (e.g, momentum and frequency) of the propagator.\npara = nothing : Additional paramenter required to evaluate the propagator.\n\n\n\n\n\n","category":"function"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.getNode-Tuple{FeynmanDiagram.DiagTree.Diagrams, Int64}","page":"Expression Tree Representation of Feynman Diagrams","title":"FeynmanDiagram.DiagTree.getNode","text":"function getNode(diag::Diagrams, nidx::Int)\n\nget Node in the diag with the index nidx.\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.getNodeWeight-Tuple{FeynmanDiagram.DiagTree.Diagrams, Int64}","page":"Expression Tree Representation of Feynman Diagrams","title":"FeynmanDiagram.DiagTree.getNodeWeight","text":"function getNodeWeight(diag::Diagrams, nidx::Int)\n\nget Node weight in the diag with the index nidx.\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.showTree-Tuple{FeynmanDiagram.DiagTree.Diagrams, Int64}","page":"Expression Tree Representation of Feynman Diagrams","title":"FeynmanDiagram.DiagTree.showTree","text":"showTree(diag::Diagrams, _root = diag.root[end]; verbose = 0, depth = 999)\n\nVisualize the diagram tree using ete3 python package\n\n#Arguments\n\ndiag: the Diagrams struct to visualize\n_root: the index of the root node to visualize\nverbose=0: the amount of information to show\ndepth=999: deepest level of the diagram tree to show\n\n\n\n\n\n","category":"method"}]
}
